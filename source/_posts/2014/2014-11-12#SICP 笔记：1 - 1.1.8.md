---
title: SICP 笔记：1 – 1.1.8
alias: '1931'
tags:
  - 技术
  - SICP
  - 笔记
date: 2014-11-12
---

> [计算机程序的构造和解释](http://www.amazon.cn/gp/product/B0011AP7RY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;creative=3132&amp;creativeASIN=B0011AP7RY&amp;linkCode=as2&amp;tag=jysperm07-23) 是这样的一本书：它将大量编程中的基本技巧，用一本正经的语言讲出来，帮助你在构建大型软件时使用这些技巧来控制代码中的复杂性。而这些技巧的共性之一就是，将复杂的事物，通过隐藏细节的方式进行组合和抽象。我认为如果一个合格的程序员只需要读三本书的话，这本书便位列其中。
>
> 写笔记是为了自己在读书的过程中能够更好地思考和理解，这份笔记的定位是排除书中的例子，将书中的结论和观点用自己的话重新描述一遍，以简体中文版为主，因为似乎翻译的质量不高，所以也会参考英文原版。本书的英文原版以 CC-BY-SA 发行，相信公开发布这份笔记没有版权方面的问题。
>
> 其实这份笔记对没有读过本书的人没有什么意义，因为本书的重要价值在于书中的例子，而这份笔记不会涉及这些例子，所以请纯当我在自言自语。

# 计算机程序的构造和解释

一个计算机语言不仅仅是让计算机去执行操作的一种方式，更是一种表述有关方法学思想的新颖的形式化媒介。因此，程序必须写得能够供人们阅读，顺便供计算机执行。在这一层次，最基本的材料并不是特定的程序设计语言的语法，不是能够有效地计算某种功能的巧妙算法，也不是算法的数学分析或计算的本质基础，而是一些能够用于控制大型软件系统的智力复杂性的技术。

我们希望读者能够对程序设计的风格要素和审美观有一种很好的感觉；他们应该掌握控制大型系统中的复杂性的主要技术；他们应该能够去读 50 页长的代码，并知道在什么时候哪些东西不需要去读，不需要去理解；应该有把握地去修改一个程序，而保持原来的作者的精神和风格。

这些技能并不仅仅限于计算机程序设计，对于所有工程设计都是通用的。我们应当在适当的时候隐藏起一些细节，通过创建抽象去控制复杂性；通过建立起约定，以一种「混合与匹配」的方式组合起一些标准的，易于理解的片段，去控制复杂性；通过发明新的程序设计语言，每种语言强调设计中的一个特定方面并降低其他方面的重要性，来控制复杂性。

## 1 构造抽象过程

「计算过程」是存在于计算机中的一类抽象事物，这些过程会去操作一些被称为「数据」的抽象事物，人们创造出一种被称为「程序」的规则模式，来指导这类过程的进行。

设计良好的计算机系统就像设计良好的汽车或核反应堆一样，具有某种模块化的设计，其中的各个部分都可以独立地构造、替换、排除错误。

虽然 Lisp 并不是一种主流语言，但其具有一些特征使它成为研究程序的设计、构造，以及各种数据结构的一种最佳媒介。其中最重要的是：计算过程的 Lisp 描述本身又可以作为 Lisp 的数据来表示和操作；它的重要性在于，现存的许多威力强大的程序设计技术，都是在致力于填平「数据」和「过程」之间的传统划分。

### 1.1 程序设计的基本元素

任何一个强有力的语言都必须提供三种机制：

*   「基本的表达形式」表示最简单的个体
*   「组合的方法」将简单个体组合成复合对象
*   「抽象的方法」将复合对象作为一个整体单元来操作

#### 1.1.1 表达式

#### 1.1.2 命名和环境

在 Lisp 中，我们可以将值与符号关联，而后又能通过符号提取出这些值，这意味着解释器必须维护着某种储存能力，以保持有关的符号和值之间的映射，这种储存被称为「环境」。

#### 1.1.3 组合式的求值

在 Lisp 中，对一个组合式的求值过程：先求值该组合式的各个子表达式；然后将最左子表达式的值所表示的过程，应用于其他子表达式所代表的参数。

我们可以用一棵树的形式来表示这一求值过程，其中每个组合式用一个带分支的节点表示，其分支对应于组合式中的运算符和运算对象，终端节点表示的是基本运算符和数值。

可以设想这些运算符和运算对象向上穿行，从终端节点开始，而后在越来越高的层次组合起来。

在性质上，这一求值过程是「递归」的，也就是说在这个计算过程中，包含着调用这个过程本身的步骤。我们应当将递归看做一种处理层次性结构的强有力的技术。

进一步的观察告诉我们，反复地应用第一个步骤，总可以将我们带到求值过程中的某一点，在这里遇到的不是组合式而是基本表达式，例如数值、内部运算符或者其他名字，处理这种基本情况的规则如下：

*   数的值就是它们所表示的数值
*   内部运算符的值就是能够完成相应操作的机器指令序列
*   其他名字的值就是在环境中关联于这个名字的那个对象

环境所扮演的角色就是用于确定表达式中各个符号的意义，如果没有关于环境的任何信息，例如 `(+ x 1)` 这样的表达式的值是毫无意义的，因为需要有环境来为符号 `x` 提供意义，甚至需要环境来为符号 `+` 提供意义。环境是一种具有普遍性的概念，它为求值过程的进行提供了一种上下文。

`define` 是目前我们看到的唯一的一种特殊形式，每个特殊形式都有其自己的求职规则。各种拥有不同的求值规则的表达式组成了程序设计语言的语法形式。Lisp 的语法非常简单，也就是说，可以被描述成一个通用规则和一组针对不多的特殊形式的专门规则。

#### 1.1.4 复合过程

「过程定义」可以为复合操作关联一个名字，而后就可以将这样的操作作为一个单元来使用了。

过程定义的一般形式是：`(define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt;)`

其中 `name` 是一个符号，这个符号将在环境中和这个过程关联起来；`formal parameters` 即形式参数是一些名字，在过程体中用于表示应用过程时与它们位置对应的各个实际参数。`body` 是一组表达式，在应用这个过程中，`body` 中的形式参数将被与之对应的实际参数取代，对这样被替换后的表达式进行求值，产出这个过程应用的结果。

我们还可以用过程作为基本构件去定义其他过程，复合过程的使用方式与基本过程完全一样，事实上如果人们只看到过程的名字，根本就无法分辨出来它是像一个基本过程一样被定义在解释器中，还是一个复合过程。

#### 1.1.5 过程应用的代换模型

对复合过程进行应用的过程被称为「代换模型」，在应用一个过程时，先将过程体中的形式参数替换为实际参数，然后像对组合式求值那样，对替换后的过程体进行求值。当然，这里描述的过程知识一个简单的庆幸，在真正的解释器中并不是这么做的。

对组合式的求值可以有两种方式：先将组合式完全展开再进行求值的模型被称为「正则序求值」，与之对应的，先求值参数再应用过程的模型被称为「应用序求值」。对于前面提到的可以通过替换来应用的过程，正则序和应用序求值的结果将会是一样的。

Lisp 采用应用序求值，部分原因在于这样可以避免对表达式的重复求值，更重要的是在超出了替换方式模拟的过程应用之后，正则序的处理将会变得非常复杂。

#### 1.1.6 条件表达式和谓词

我们用术语「谓词」指那些返回真或假的过程，也指那种能求出真或假的值的表达式。

`and` 和 `or` 这些逻辑运算符用来构造复杂谓词。解释器将会对 `and` 或 `or` 的参数从左至右逐个求值，直到一个参数的值是真作为结果，跳过对右边其他表达式的求值。`and` 和 `or` 都是特殊形式而不是普通的过程，因为他们的子表达式不一定都会被求值，`not` 则是一个普通的过程。

#### 1.1.7 实例：采用牛顿法求平方根

在数学中，人们通常关心的是说明性的知识(是什么), 而在计算机科学里，人们则通常关心行动性的描述(怎么做). 说明性描述和行动性描述有着内在的联系，例如，说一个程序产生的结果是「正确」的，就是给出了一个有关该程序性质的说明性描述。在编程中存在着大量的研究工作，其目标就是通过一些技术，来设法证明一个程序是正确的。其根源就是行动性描述(程序是由它们构筑起来的)和说明性描述(它们可以用来推导出某些结果)之间的差异。有一个在当前程序设计语言设计领域中很重要的问题，就是所谓的「终极语言」，在这种语言中编程就是写说明性的语句，通过将解释器做得足够复杂，程序员描述了需要做什么之后，解释器就能自动产生怎样做的知识。一般而言这是不可能做到的，但在这一领域人们已经取得了巨大的进步。

#### 1.1.8 过程作为黑箱抽象

一个过程定义应该能隐藏一些细节，使过程的调用者不必考虑和了解这些细节，而是作为一个黑箱来接受它。

过程的调用者不需要关心的细节之一就是过程中形式参数的名字，过程的形式参数是局部于这个过程的，一个过程的定义约束了它的所有形式参数，这样的名字被称为「约束变量」。如果在一个完整的过程定义中将某个约束变量统一更名，这一过程的意义将不会有任何改变。一个名字的定义被约束于的那一集表达式被称为这个名字的作用域，在一个过程定义中，被声明为这个过程的形式参数的那些约束变量，就以这个过程的过程体作为它们的作用域。

如果一个变量不是被约束的，我们就称之为「自由」的。如果在一个过程的定义中，将一个自由的变量的名字加入参数列表就会引起一个错误，因为这样就将一个原本自由的名字变成了约束的，使其捕捉到了一个错误的值。

我们也可以将一个过程的定义局部于另一个过程，使这个过程成为其的子过程或者说是辅助过程。子过程还可以共享父级过程的约束变量，在父过程被调用的时候，约束变量被与实际参数关联起来，变成了子过程的自由变量，这种方式被称为「词法作用域」。

> [计算机程序的构造和解释](http://www.amazon.cn/gp/product/B0011AP7RY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;creative=3132&amp;creativeASIN=B0011AP7RY&amp;linkCode=as2&amp;tag=jysperm07-23) 是这样的一本书：它将大量编程中的基本技巧，用一本正经的语言讲出来，帮助你在构建大型软件时使用这些技巧来控制代码中的复杂性。而这些技巧的共性之一就是，将复杂的事物，通过隐藏细节的方式进行组合和抽象。我认为如果一个合格的程序员只需要读三本书的话，这本书便位列其中。
